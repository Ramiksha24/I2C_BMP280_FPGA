// Fixed I2C Master with Read AND Write Support
// Bug fix: Proper state transitions to prevent loops

module i2c_master_rw (
    input wire clk,              // 100 MHz
    input wire rst_n,            
    
    // Control
    input wire start,            // Pulse to start transaction
    input wire [7:0] slave_addr, // 7-bit I2C address
    input wire [7:0] reg_addr,   // Register address
    input wire [7:0] wr_data,    // Data to write (for write operations)
    input wire read_mode,        // 1 = Read, 0 = Write
    output reg [7:0] data_out,   // Data read (for read operations)
    output reg busy,
    output reg done,
    
    // I2C Physical Pins
    output reg scl,
    inout wire sda,
    
    // Debug signals for ILA
    output wire debug_sda_out,
    output wire debug_sda_in,
    output wire debug_sda_en,
    output wire [3:0] debug_state,
    output wire [3:0] debug_bit_cnt,
    output wire [7:0] debug_shift_reg
);

    parameter CLKDIV = 66;  // 400kHz I2C from 100MHz clock
    
    reg [7:0] clk_cnt;
    reg [2:0] phase;
    reg phase_tick;
    
    // Clock generation
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            clk_cnt <= 0;
            phase <= 0;
            phase_tick <= 0;
        end else if (busy) begin
            if (clk_cnt >= CLKDIV-1) begin
                clk_cnt <= 0;
                phase_tick <= 1;
                phase <= (phase == 3) ? 0 : phase + 1;
            end else begin
                clk_cnt <= clk_cnt + 1;
                phase_tick <= 0;
            end
        end else begin
            clk_cnt <= 0;
            phase <= 0;
            phase_tick <= 0;
        end
    end
    
    // State machine
    localparam IDLE      = 0;
    localparam START_BIT = 1;
    localparam ADDR_W    = 2;
    localparam ACK1      = 3;
    localparam REG_ADDR  = 4;
    localparam ACK2      = 5;
    localparam WRITE_DATA = 6;
    localparam ACK_WR    = 7;
    localparam RESTART   = 8;
    localparam ADDR_R    = 9;
    localparam ACK3      = 10;
    localparam READ_DATA = 11;
    localparam NACK      = 12;
    localparam STOP_BIT  = 13;
    
    reg [3:0] state;
    reg [3:0] next_state;  // Add explicit next state
    reg [3:0] bit_cnt;
    reg [7:0] shift_reg;
    reg sda_out;
    reg sda_en;
    reg saved_read_mode;
    
    wire sda_in;
    
    // IOBUF for SDA
    IOBUF IOBUF_sda (
        .IO(sda),
        .I(sda_out),
        .O(sda_in),
        .T(sda_en)
    );
    
    // Debug outputs
    assign debug_sda_out = sda_out;
    assign debug_sda_in = sda_in;
    assign debug_sda_en = sda_en;
    assign debug_state = state;
    assign debug_bit_cnt = bit_cnt;
    assign debug_shift_reg = shift_reg;
    
    // Main state machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            next_state <= IDLE;
            scl <= 1;
            sda_out <= 1;
            sda_en <= 0;
            busy <= 0;
            done <= 0;
            bit_cnt <= 0;
            data_out <= 0;
            saved_read_mode <= 0;
        end else begin
            done <= 0;
            
            case (state)
                IDLE: begin
                    scl <= 1;
                    sda_out <= 1;
                    sda_en <= 0;
                    busy <= 0;
                    bit_cnt <= 0;
                    if (start) begin
                        busy <= 1;
                        saved_read_mode <= read_mode;
                        state <= START_BIT;
                    end
                end
                
                START_BIT: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 1;
                        sda_out <= 1;
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        sda_out <= 0;  // START condition
                    end else if (phase_tick && phase == 2) begin
                        scl <= 0;
                    end else if (phase_tick && phase == 3) begin
                        shift_reg <= {slave_addr, 1'b0};
                        bit_cnt <= 8;
                        state <= ADDR_W;
                    end
                end
                
                ADDR_W: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_out <= shift_reg[7];
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        shift_reg <= {shift_reg[6:0], 1'b0};
                        bit_cnt <= bit_cnt - 1;
                        if (bit_cnt == 1)
                            state <= ACK1;
                    end
                end
                
                ACK1: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_en <= 1;  // Release for ACK
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;  // Sample ACK
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        shift_reg <= reg_addr;
                        bit_cnt <= 8;
                        state <= REG_ADDR;
                    end
                end
                
                REG_ADDR: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_out <= shift_reg[7];
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        shift_reg <= {shift_reg[6:0], 1'b0};
                        bit_cnt <= bit_cnt - 1;
                        if (bit_cnt == 1)
                            state <= ACK2;
                    end
                end
                
                ACK2: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_en <= 1;  // Release for ACK
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        if (saved_read_mode) begin
                            state <= RESTART;
                        end else begin
                            shift_reg <= wr_data;
                            bit_cnt <= 8;
                            state <= WRITE_DATA;
                        end
                    end
                end
                
                WRITE_DATA: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_out <= shift_reg[7];
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        shift_reg <= {shift_reg[6:0], 1'b0};
                        bit_cnt <= bit_cnt - 1;
                        if (bit_cnt == 1)
                            state <= ACK_WR;
                    end
                end
                
                ACK_WR: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_en <= 1;  // Release for ACK
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;  // Sample ACK
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        state <= STOP_BIT;
                    end
                end
                
                RESTART: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_out <= 1;
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        sda_out <= 0;  // Repeated START
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        shift_reg <= {slave_addr, 1'b1};
                        bit_cnt <= 8;
                        state <= ADDR_R;
                    end
                end
                
                ADDR_R: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_out <= shift_reg[7];
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        shift_reg <= {shift_reg[6:0], 1'b0};
                        bit_cnt <= bit_cnt - 1;
                        if (bit_cnt == 1)
                            state <= ACK3;
                    end
                end
                
                ACK3: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_en <= 1;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        bit_cnt <= 8;
                        state <= READ_DATA;
                    end
                end
                
                READ_DATA: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_en <= 1;  // Input mode
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                        shift_reg <= {shift_reg[6:0], sda_in};
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        bit_cnt <= bit_cnt - 1;
                        if (bit_cnt == 1)
                            state <= NACK;
                    end
                end
                
                NACK: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_out <= 1;  // NACK
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 3) begin
                        scl <= 0;
                        state <= STOP_BIT;
                    end
                end
                
                STOP_BIT: begin
                    if (phase_tick && phase == 0) begin
                        scl <= 0;
                        sda_out <= 0;
                        sda_en <= 0;
                    end else if (phase_tick && phase == 1) begin
                        scl <= 1;
                    end else if (phase_tick && phase == 2) begin
                        sda_out <= 1;  // STOP condition
                    end else if (phase_tick && phase == 3) begin
                        if (saved_read_mode)
                            data_out <= shift_reg;
                        done <= 1;
                        busy <= 0;
                        state <= IDLE;
                    end
                end
                
                default: state <= IDLE;
            endcase
        end
    end

endmodule
