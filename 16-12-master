module i2c_master_ila (
    input wire clk,
    input wire rst_n,
    
    // Control
    input wire start,
    input wire [7:0] slave_addr,
    input wire [7:0] reg_addr,
    output reg [7:0] data_out,
    output reg busy,
    output reg done,
    output reg error,
    
    // I2C Physical Pins
    output wire scl,
    inout wire sda,
    
    // Debug signals for ILA
    output wire debug_scl_out,
    output wire debug_sda_out,
    output wire debug_sda_in,
    output wire debug_sda_oe,
    output wire [3:0] debug_state,
    output wire [3:0] debug_bit_cnt,
    output wire [7:0] debug_shift_reg,
    output wire [7:0] debug_clk_cnt,
    output wire [2:0] debug_phase
);

    parameter CLKDIV = 62;  // 100kHz I2C
    
    reg [7:0] clk_cnt;
    reg [2:0] phase;
    reg phase_tick;
    
    // State machine
    localparam IDLE = 0, START_BIT = 1, 
               ADDR_W = 2, ACK1 = 3,
               REG_ADDR = 4, ACK2 = 5,
               RESTART = 6, ADDR_R = 7, 
               ACK3 = 8, READ_DATA = 9,
               NACK = 10, STOP_BIT = 11;
    
    reg [3:0] state;
    reg [3:0] bit_cnt;
    reg [7:0] shift_reg;
    reg scl_out;
    reg sda_out_internal;
    reg sda_oe;
    reg ack_error;
    
    // Latched inputs
    reg [7:0] slave_addr_latched;
    reg [7:0] reg_addr_latched;
    
    // ===== IOBUF for SDA =====
    wire sda_in;
    
    IOBUF #(
        .DRIVE(12),
        .IBUF_LOW_PWR("TRUE"),
        .IOSTANDARD("LVCMOS33"),
        .SLEW("SLOW")
    ) IOBUF_sda_inst (
        .O(sda_in),              // Input: read from pin
        .IO(sda),                // Bidirectional pin
        .I(sda_out_internal),    // Output: drive to pin
        .T(~sda_oe)              // Tristate control (active LOW: 0=output, 1=Z)
    );
    
    // SCL is output only
    assign scl = scl_out;
    
    // Debug signals
    assign debug_scl_out = scl_out;
    assign debug_sda_out = sda_out_internal;
    assign debug_sda_in = sda_in;
    assign debug_sda_oe = sda_oe;
    assign debug_state = state;
    assign debug_bit_cnt = bit_cnt;
    assign debug_shift_reg = shift_reg;
    assign debug_clk_cnt = clk_cnt;
    assign debug_phase = phase;
    
    // Clock generation
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            clk_cnt <= 0;
            phase <= 0;
            phase_tick <= 0;
        end else if (busy) begin
            if (clk_cnt >= CLKDIV-1) begin
                clk_cnt <= 0;
                phase_tick <= 1;
                if (phase == 3)
                    phase <= 0;
                else
                    phase <= phase + 1;
            end else begin
                clk_cnt <= clk_cnt + 1;
                phase_tick <= 0;
            end
        end else begin
            clk_cnt <= 0;
            phase <= 0;
            phase_tick <= 0;
        end
    end
    
    // Main state machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            scl_out <= 1;
            sda_out_internal <= 1;
            sda_oe <= 1;
            busy <= 0;
            done <= 0;
            error <= 0;
            bit_cnt <= 0;
            data_out <= 0;
            ack_error <= 0;
            shift_reg <= 8'h00; 
            slave_addr_latched <= 8'h00;
            reg_addr_latched <= 8'h00;
        end else begin
            done <= 0;
            
            case (state)
                IDLE: begin
                    scl_out <= 1;
                    sda_out_internal <= 1;
                    sda_oe <= 1;
                    busy <= 0;
                    error <= 0;
                    bit_cnt <= 0;
                    ack_error <= 0;
                    
                    if (start && !busy) begin
                        // Latch inputs
                        slave_addr_latched <= slave_addr;
                        reg_addr_latched <= reg_addr;
                        busy <= 1;
                        state <= START_BIT;
                        // ? FIX: Load shift_reg with slave address + write bit (0)
                        shift_reg <= {slave_addr[7:1], 1'b0};  // 0xEC for slave_addr=0x76
                    end
                end
                
                START_BIT: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 1;
                                sda_out_internal <= 1;
                                sda_oe <= 1;
                            end
                            1: begin
                                scl_out <= 1;
                                sda_out_internal <= 0;  // START condition
                                sda_oe <= 1;
                            end
                            2: begin
                                scl_out <= 1;
                                sda_out_internal <= 0;
                                bit_cnt <= 8;
                            end
                            3: begin
                                scl_out <= 0;
                                // ? FIX: Set first bit of 0xEC
                                sda_out_internal <= shift_reg[7];
                                sda_oe <= 1;
                                state <= ADDR_W;
                            end
                        endcase
                    end
                end
                
                ADDR_W: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_out_internal <= shift_reg[7];
                                sda_oe <= 1;
                            end
                            1: begin
                                scl_out <= 0;
                            end
                            2: begin
                                scl_out <= 1;  // Data should be stable now
                            end
                            3: begin
                                scl_out <= 1;
                                bit_cnt <= bit_cnt - 1;
                                
                                if (bit_cnt == 1) begin
                                    state <= ACK1;
                                    sda_oe <= 0;  // Release for ACK
                                end else begin
                                    shift_reg <= {shift_reg[6:0], 1'b0};
                                    sda_out_internal <= shift_reg[6];  // Next bit
                                end
                            end
                        endcase
                    end
                end
                
                ACK1: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_oe <= 0;  // Tristate
                            end
                            1: begin
                                scl_out <= 0;
                                // Pre-load register address (0xD0)
                                shift_reg <= reg_addr_latched;
                                bit_cnt <= 8;
                            end
                            2: begin
                                scl_out <= 1;
                            end
                            3: begin
                                scl_out <= 1;
                                if (sda_in == 1) begin
                                    ack_error <= 1;
                                end
                                // Prepare for next byte
                                sda_out_internal <= shift_reg[7];  // First bit of 0xD0
                                sda_oe <= 1;
                                state <= REG_ADDR;
                            end
                        endcase
                    end
                end
                
                REG_ADDR: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_out_internal <= shift_reg[7];
                                sda_oe <= 1;
                            end
                            1: begin
                                scl_out <= 0;
                            end
                            2: begin
                                scl_out <= 1;
                            end
                            3: begin
                                scl_out <= 1;
                                bit_cnt <= bit_cnt - 1;
                                
                                if (bit_cnt == 1) begin
                                    state <= ACK2;
                                    sda_oe <= 0;
                                end else begin
                                    shift_reg <= {shift_reg[6:0], 1'b0};
                                    sda_out_internal <= shift_reg[6];
                                end
                            end
                        endcase
                    end
                end
                
                ACK2: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_oe <= 0;
                            end
                            1: begin
                                scl_out <= 0;
                            end
                            2: begin
                                scl_out <= 1;
                            end
                            3: begin
                                scl_out <= 1;
                                if (sda_in == 1) begin
                                    ack_error <= 1;
                                end
                                sda_out_internal <= 1;
                                sda_oe <= 1;
                                state <= RESTART;
                            end
                        endcase
                    end
                end
                
                RESTART: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_out_internal <= 1;
                                sda_oe <= 1;
                            end
                            1: begin
                                scl_out <= 1;
                                sda_out_internal <= 1;
                                // Pre-load slave address with read bit (0xED)
                                shift_reg <= {slave_addr_latched[7:1], 1'b1};
                                bit_cnt <= 8;
                            end
                            2: begin
                                scl_out <= 1;
                                sda_out_internal <= 0;  // RESTART condition
                            end
                            3: begin
                                scl_out <= 0;
                                sda_out_internal <= shift_reg[7];  // First bit of 0xED
                                sda_oe <= 1;
                                state <= ADDR_R;
                            end
                        endcase
                    end
                end
                
                ADDR_R: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_out_internal <= shift_reg[7];
                                sda_oe <= 1;
                            end
                            1: begin
                                scl_out <= 0;
                            end
                            2: begin
                                scl_out <= 1;
                            end
                            3: begin
                                scl_out <= 1;
                                bit_cnt <= bit_cnt - 1;
                                
                                if (bit_cnt == 1) begin
                                    state <= ACK3;
                                    sda_oe <= 0;
                                end else begin
                                    shift_reg <= {shift_reg[6:0], 1'b0};
                                    sda_out_internal <= shift_reg[6];
                                end
                            end
                        endcase
                    end
                end
                
                ACK3: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_oe <= 0;
                            end
                            1: begin
                                scl_out <= 0;
                                shift_reg <= 8'h00;
                                bit_cnt <= 8;
                            end
                            2: begin
                                scl_out <= 1;
                            end
                            3: begin
                                scl_out <= 1;
                                if (sda_in == 1) begin
                                    ack_error <= 1;
                                end
                                state <= READ_DATA;
                            end
                        endcase
                    end
                end
                
                READ_DATA: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_oe <= 0;  // Master releases SDA
                            end
                            1: begin
                                scl_out <= 0;
                            end
                            2: begin
                                scl_out <= 1;
                                // Sample SDA when SCL is high
                                shift_reg <= {shift_reg[6:0], sda_in};
                                
                                if (bit_cnt == 1) begin
                                    data_out <= {shift_reg[6:0], sda_in};
                                end
                            end
                            3: begin
                                scl_out <= 1;
                                bit_cnt <= bit_cnt - 1;
                                
                                if (bit_cnt == 1) begin
                                    state <= NACK;
                                    sda_out_internal <= 1;  // NACK
                                    sda_oe <= 1;
                                end
                            end
                        endcase
                    end
                end
                
                NACK: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_out_internal <= 1;  // NACK
                                sda_oe <= 1;
                            end
                            1: begin
                                scl_out <= 0;
                            end
                            2: begin
                                scl_out <= 1;
                            end
                            3: begin
                                scl_out <= 1;
                                state <= STOP_BIT;
                            end
                        endcase
                    end
                end
                
                STOP_BIT: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl_out <= 0;
                                sda_out_internal <= 0;
                                sda_oe <= 1;
                            end
                            1: begin
                                scl_out <= 1;
                                sda_out_internal <= 0;
                            end
                            2: begin
                                scl_out <= 1;
                                sda_out_internal <= 1;  // STOP condition
                            end
                            3: begin
                                scl_out <= 1;
                                sda_out_internal <= 1;
                                done <= 1;
                                error <= ack_error;
                                busy <= 0;
                                state <= IDLE;
                            end
                        endcase
                    end
                end
                
                default: state <= IDLE;
            endcase
        end
    end

endmodule
