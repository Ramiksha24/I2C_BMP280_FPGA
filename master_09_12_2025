/*
 * I2C Master for BMP280 Sensor
 * Adapted for Artix-7 FPGA @ 200MHz
 * Target I2C Speed: 400kHz Fast Mode
 */

`timescale 1ns/1ps
module i2c_master_bmp280(
   input             clk,
    input             reset_n,
    input      [7:0]  i_addr_w_rw,
    input      [15:0] i_sub_addr,
    input             i_sub_len,
    input      [23:0] i_byte_len,
    input      [7:0]  i_data_write,
    input             req_trans,
    
    output reg [7:0]  data_out,
    output reg        valid_out,
    
    // I2C lines - CHANGED TO SEPARATE SIGNALS
    output            scl_out,      // SCL output value
    input             scl_in,       // SCL input value
    output            scl_oe,       // SCL output enable
    
    output            sda_out,      // SDA output value
    input             sda_in,       // SDA input value
    output            sda_oe,       // SDA output enable
    
    output reg        req_data_chunk,
    output reg        busy,
    output reg        nack,
    // ILA Debug signals
    output wire [3:0] dbg_state,
    output wire [7:0] dbg_byte_sr,
    output wire [2:0] dbg_bit_cntr,
    output wire       dbg_scl_internal,
    output wire       dbg_sda_internal,
    output wire       dbg_sda_in,
    output wire       dbg_scl_in,
    output wire [23:0] dbg_byte_count
);

    // State machine states
    localparam [3:0] IDLE        = 4'd0,
                     START       = 4'd1,
                     RESTART     = 4'd2,
                     SLAVE_ADDR  = 4'd3,
                     SUB_ADDR    = 4'd4,
                     READ        = 4'd5,
                     WRITE       = 4'd6,
                     GRAB_DATA   = 4'd7,
                     ACK_NACK_RX = 4'd8,
                     ACK_NACK_TX = 4'd9,
                     STOP        = 4'd10,
                     RELEASE_BUS = 4'd11;
    
    // Clock divider for 400kHz I2C from 200MHz
    // (200MHz / 400kHz) / 2 = 250
    localparam [15:0] DIV_200MHZ = 16'd250;
    
    // Timing parameters (in 200MHz clock cycles)
    localparam [7:0] START_IND_SETUP = 70,   // Before SCL negedge
                     DATA_HOLD_TIME  = 3,     // After SCL negedge
                     STOP_IND_SETUP  = 60;    // After SCL posedge
    
    // Internal registers
    reg [3:0]  state, next_state;
    reg        reg_sda_o;
    reg [7:0]  addr;
    reg        rw;
    reg [15:0] sub_addr;
    reg        sub_len;
    reg [23:0] byte_len;
    reg        en_scl;
    reg        byte_sent;
    reg [23:0] num_byte_sent;
    reg [2:0]  cntr;
    reg [7:0]  byte_sr;
    reg        read_sub_addr_sent_flag;
    reg [7:0]  data_to_write;
    reg [7:0]  data_in_sr;
    
    // Clock generation
    reg        clk_i2c;
    reg [15:0] clk_i2c_cntr;
    
    // SDA/SCL sampling
    reg [1:0]  sda_curr;
    reg        sda_prev;
    reg        scl_prev, scl_curr;
    
    // Control flags
    reg        ack_in_prog;
    reg        ack_nack;
    reg        en_end_indicator;
    reg        grab_next_data;
    reg        scl_is_high;
    reg        scl_is_low;
    
    // ILA debug assignments
    assign dbg_state = state;
    assign dbg_byte_sr = byte_sr;
    assign dbg_bit_cntr = cntr;
    assign dbg_scl_internal = clk_i2c;
    assign dbg_sda_internal = reg_sda_o;
    assign dbg_sda_in = sda_prev;
    assign dbg_scl_in = scl_curr;
    assign dbg_byte_count = num_byte_sent;
    
    //==========================================================================
    // 400kHz Clock Generation (synchronous to 200MHz input)
    //==========================================================================
    always @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            clk_i2c_cntr <= 0;
            clk_i2c <= 1'b1;
        end else if (!en_scl) begin
            clk_i2c_cntr <= 0;
            clk_i2c <= 1'b1;
        end else begin
            clk_i2c_cntr <= clk_i2c_cntr + 1;
            if (clk_i2c_cntr == DIV_200MHZ - 1) begin
                clk_i2c <= ~clk_i2c;
                clk_i2c_cntr <= 0;
            end
        end
    end
    
    //==========================================================================
    // Main State Machine
    //==========================================================================
    always @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            // Outputs
            data_out <= 0;
            valid_out <= 0;
            req_data_chunk <= 0;
            busy <= 0;
            nack <= 0;
            
            // Internal state
            addr <= 0;
            rw <= 0;
            sub_addr <= 0;
            sub_len <= 0;
            byte_len <= 0;
            en_scl <= 0;
            byte_sent <= 0;
            num_byte_sent <= 0;
            cntr <= 0;
            byte_sr <= 0;
            read_sub_addr_sent_flag <= 0;
            data_to_write <= 0;
            data_in_sr <= 0;
            ack_nack <= 0;
            ack_in_prog <= 0;
            en_end_indicator <= 0;
            scl_is_high <= 0;
            scl_is_low <= 0;
            grab_next_data <= 0;
            reg_sda_o <= 1'bz;
            state <= IDLE;
            next_state <= IDLE;
        end else begin
            // Default: deassert single-cycle signals
            valid_out <= 0;
            req_data_chunk <= 0;
            
            case (state)
                //==============================================================
                // IDLE - Wait for transaction request
                //==============================================================
                IDLE: begin
                    if (req_trans && !busy) begin
                        busy <= 1;
                        state <= START;
                        next_state <= SLAVE_ADDR;
                        
                        // Latch inputs
                        addr <= i_addr_w_rw;
                        rw <= i_addr_w_rw[0];
                        sub_addr <= i_sub_len ? i_sub_addr : {i_sub_addr[7:0], 8'b0};
                        sub_len <= i_sub_len;
                        data_to_write <= i_data_write;
                        byte_len <= i_byte_len;
                        
                        // Start clock
                        en_scl <= 1;
                        reg_sda_o <= 1;
                        
                        // Reset flags
                        nack <= 0;
                        read_sub_addr_sent_flag <= 0;
                        num_byte_sent <= 0;
                        byte_sent <= 0;
                    end
                end
                
                //==============================================================
                // START - Generate START condition
                //==============================================================
                START: begin
                    if (scl_prev && scl_curr && clk_i2c_cntr == START_IND_SETUP) begin
                        reg_sda_o <= 0;  // Pull SDA low while SCL high
                        byte_sr <= {addr[7:1], 1'b0};  // Always write first (even for reads)
                        state <= SLAVE_ADDR;
                    end
                end
                
                //==============================================================
                // RESTART - Generate repeated START
                //==============================================================
                RESTART: begin
                    if (!scl_curr && scl_prev) begin
                        reg_sda_o <= 1;  // Release SDA on SCL falling edge
                    end
                    
                    if (!scl_prev && scl_curr) begin
                        scl_is_high <= 1;
                    end
                    
                    if (scl_is_high && clk_i2c_cntr == START_IND_SETUP) begin
                        scl_is_high <= 0;
                        reg_sda_o <= 0;  // Pull SDA low for START
                        state <= SLAVE_ADDR;
                        byte_sr <= addr;
                    end
                end
                
                //==============================================================
                // SLAVE_ADDR - Send slave address + R/W bit
                //==============================================================
                SLAVE_ADDR: begin
                    if (byte_sent && cntr[0]) begin
                        byte_sent <= 0;
                        next_state <= read_sub_addr_sent_flag ? READ : SUB_ADDR;
                        byte_sr <= sub_addr[15:8];
                        state <= ACK_NACK_RX;
                        reg_sda_o <= 1'bz;
                        cntr <= 0;
                    end else begin
                        if (!scl_curr && scl_prev) begin
                            scl_is_low <= 1;
                        end
                        
                        if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                            scl_is_low <= 0;
                        end
                    end
                end
                
                //==============================================================
                // SUB_ADDR - Send register address
                //==============================================================
                SUB_ADDR: begin
                    if (byte_sent && cntr[0]) begin
                        if (sub_len) begin
                            // 16-bit address: send second byte
                            state <= ACK_NACK_RX;
                            next_state <= SUB_ADDR;
                            sub_len <= 0;
                            byte_sr <= sub_addr[7:0];
                        end else begin
                            // Address complete
                            next_state <= rw ? RESTART : WRITE;
                            byte_sr <= rw ? byte_sr : data_to_write;
                            read_sub_addr_sent_flag <= 1;
                        end
                        cntr <= 0;
                        byte_sent <= 0;
                        state <= ACK_NACK_RX;
                        reg_sda_o <= 1'bz;
                    end else begin
                        if (!scl_curr && scl_prev) begin
                            scl_is_low <= 1;
                        end
                        
                        if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                            scl_is_low <= 0;
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                        end
                    end
                end
                
                //==============================================================
                // READ - Read data bytes from slave
                //==============================================================
                READ: begin
                    if (byte_sent) begin
                        byte_sent <= 0;
                        data_out <= data_in_sr;
                        valid_out <= 1;
                        state <= ACK_NACK_TX;
                        next_state <= (num_byte_sent == byte_len - 1) ? STOP : READ;
                        ack_nack <= (num_byte_sent == byte_len - 1);  // NACK last byte
                        num_byte_sent <= num_byte_sent + 1;
                        ack_in_prog <= 1;
                    end else begin
                        if (!scl_prev && scl_curr) begin
                            scl_is_high <= 1;
                        end
                        
                        if (scl_is_high && clk_i2c_cntr == START_IND_SETUP) begin
                            valid_out <= 0;
                            {byte_sent, cntr} <= cntr + 1;
                            data_in_sr <= {data_in_sr[6:0], sda_prev};
                            scl_is_high <= 0;
                        end
                    end
                end
                
                //==============================================================
                // WRITE - Write data bytes to slave
                //==============================================================
                WRITE: begin
                    if (byte_sent && cntr[0]) begin
                        cntr <= 0;
                        byte_sent <= 0;
                        state <= ACK_NACK_RX;
                        reg_sda_o <= 1'bz;
                        next_state <= (num_byte_sent == byte_len - 1) ? STOP : GRAB_DATA;
                        num_byte_sent <= num_byte_sent + 1;
                        grab_next_data <= 1;
                    end else begin
                        if (!scl_curr && scl_prev) begin
                            scl_is_low <= 1;
                        end
                        
                        if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                            scl_is_low <= 0;
                        end
                    end
                end
                
                //==============================================================
                // GRAB_DATA - Request next byte from controller
                //==============================================================
                GRAB_DATA: begin
                    if (grab_next_data) begin
                        req_data_chunk <= 1;
                        grab_next_data <= 0;
                    end else begin
                        state <= WRITE;
                        byte_sr <= i_data_write;
                    end
                end
                
                //==============================================================
                // ACK_NACK_RX - Receive ACK/NACK from slave
                //==============================================================
                ACK_NACK_RX: begin
                    if (!scl_prev && scl_curr) begin
                        scl_is_high <= 1;
                    end
                    
                    if (scl_is_high && clk_i2c_cntr == START_IND_SETUP) begin
                        if (!sda_prev) begin
                            // ACK received
                            state <= next_state;
                        end else begin
                            // NACK received
                            nack <= 1;
                            busy <= 0;
                            reg_sda_o <= 1'bz;
                            en_scl <= 0;
                            state <= IDLE;
                        end
                        scl_is_high <= 0;
                    end
                end
                
                //==============================================================
                // ACK_NACK_TX - Send ACK/NACK to slave
                //==============================================================
                ACK_NACK_TX: begin
                    if (!scl_curr && scl_prev) begin
                        scl_is_low <= 1;
                    end
                    
                    if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                        if (ack_in_prog) begin
                            reg_sda_o <= ack_nack;  // 0=ACK, 1=NACK
                            ack_in_prog <= 0;
                        end else begin
                            reg_sda_o <= (next_state == STOP) ? 1'b0 : 1'bz;
                            en_end_indicator <= (next_state == STOP);
                            state <= next_state;
                        end
                        scl_is_low <= 0;
                    end
                end
                
                //==============================================================
                // STOP - Generate STOP condition
                //==============================================================
                STOP: begin
                    if (!scl_curr && scl_prev && !rw) begin
                        reg_sda_o <= 0;
                        en_end_indicator <= 1;
                    end
                    
                    if (scl_curr && scl_prev && en_end_indicator) begin
                        scl_is_high <= 1;
                        en_end_indicator <= 0;
                    end
                    
                    if (scl_is_high && clk_i2c_cntr == STOP_IND_SETUP) begin
                        reg_sda_o <= 1;  // Release SDA while SCL high
                        state <= RELEASE_BUS;
                        scl_is_high <= 0;
                    end
                end
                
                //==============================================================
                // RELEASE_BUS - Return to idle
                //==============================================================
                RELEASE_BUS: begin
                    if (clk_i2c_cntr == DIV_200MHZ - 3) begin
                        en_scl <= 0;
                        state <= IDLE;
                        reg_sda_o <= 1'bz;
                        busy <= 0;
                    end
                end
                
                default: state <= IDLE;
            endcase
        end
    end
    
    //==========================================================================
    // SDA/SCL Sampling (synchronizer on negedge for metastability)
    //==========================================================================
    always @(negedge clk or negedge reset_n) begin
    if (!reset_n) begin
        sda_curr <= 2'b11;
        sda_prev <= 1;
        scl_curr <= 1;
        scl_prev <= 1;
    end else begin
        sda_curr <= {sda_curr[0], sda_in};  // â† Changed from sda_o to sda_in
        sda_prev <= sda_curr[1];
        scl_curr <= clk_i2c;
        scl_prev <= scl_curr;
    end
end
    //==========================================================================
    // I2C Pin Assignments
    //==========================================================================
   // NEW (CORRECT):
assign sda_out = (reg_sda_o === 1'bz) ? 1'b1 : reg_sda_o;
assign sda_oe  = (reg_sda_o !== 1'bz);  // Output enable when NOT high-Z

assign scl_out = clk_i2c;
assign scl_oe  = en_scl;

endmodule
