/*
 * I2C Master for BMP280 Sensor - FIXED sda_oe control
 * Adapted for Artix-7 FPGA @ 100MHz (changed from 200MHz in comments)
 * Target I2C Speed: 400kHz Fast Mode
 */

`timescale 1ns/1ps
module i2c_master_bmp280(
    input             clk,
    input             reset_n,
    input      [7:0]  i_addr_w_rw,
    input      [15:0] i_sub_addr,
    input             i_sub_len,
    input      [23:0] i_byte_len,
    input      [7:0]  i_data_write,
    input             req_trans,
    
    output reg [7:0]  data_out,
    output reg        valid_out,
    
    // I2C lines
    output            scl_out,
    input             scl_in,
    output            scl_oe,
    
    output            sda_out,
    input             sda_in,
    output            sda_oe,
    
    output reg        req_data_chunk,
    output reg        busy,
    output reg        nack,
    
    // ILA Debug signals
    output wire [3:0] dbg_state,
    output wire [7:0] dbg_byte_sr,
    output wire [2:0] dbg_bit_cntr,
    output wire       dbg_scl_internal,
    output wire       dbg_sda_internal,
    output wire       dbg_sda_in,
    output wire       dbg_scl_in,
    output wire [23:0] dbg_byte_count
);

    // State machine states
    localparam [3:0] IDLE        = 4'd0,
                     START       = 4'd1,
                     RESTART     = 4'd2,
                     SLAVE_ADDR  = 4'd3,
                     SUB_ADDR    = 4'd4,
                     READ        = 4'd5,
                     WRITE       = 4'd6,
                     GRAB_DATA   = 4'd7,
                     ACK_NACK_RX = 4'd8,
                     ACK_NACK_TX = 4'd9,
                     STOP        = 4'd10,
                     RELEASE_BUS = 4'd11;
    
    // Clock divider for 100kHz I2C from 100MHz
    // (100MHz / 100kHz) / 2 = 500
    localparam [15:0] DIV_100MHZ = 16'd500;
    
    // Timing parameters (in 100MHz clock cycles)
    localparam [7:0] START_IND_SETUP = 140,  // Before SCL negedge (adjusted for 100kHz)
                     DATA_HOLD_TIME  = 10,    // After SCL negedge (more margin at 100kHz)
                     STOP_IND_SETUP  = 120;   // After SCL posedge (adjusted for 100kHz)
    
    // Internal registers
    reg [3:0]  state, next_state;
    reg        reg_sda_o;
    reg        reg_sda_oe;  // ← NEW! Explicit output enable
    reg [7:0]  addr;
    reg        rw;
    reg [15:0] sub_addr;
    reg        sub_len;
    reg [23:0] byte_len;
    reg        en_scl;
    reg        byte_sent;
    reg [23:0] num_byte_sent;
    reg [2:0]  cntr;
    reg [7:0]  byte_sr;
    reg        read_sub_addr_sent_flag;
    reg [7:0]  data_to_write;
    reg [7:0]  data_in_sr;
    
    // Clock generation
    reg        clk_i2c;
    reg [15:0] clk_i2c_cntr;
    
    // SDA/SCL sampling
    reg [1:0]  sda_curr;
    reg        sda_prev;
    reg        scl_prev, scl_curr;
    
    // Control flags
    reg        ack_in_prog;
    reg        ack_nack;
    reg        en_end_indicator;
    reg        grab_next_data;
    reg        scl_is_high;
    reg        scl_is_low;
    
    // ILA debug assignments
    assign dbg_state = state;
    assign dbg_byte_sr = byte_sr;
    assign dbg_bit_cntr = cntr;
    assign dbg_scl_internal = clk_i2c;
    assign dbg_sda_internal = reg_sda_o;
    assign dbg_sda_in = sda_prev;
    assign dbg_scl_in = scl_curr;
    assign dbg_byte_count = num_byte_sent;
    
    //==========================================================================
    // 400kHz Clock Generation (from 100MHz input)
    //==========================================================================
    always @(posedge clk or posedge reset_n) begin
        if (reset_n) begin
            clk_i2c_cntr <= 0;
            clk_i2c <= 1'b1;
        end else if (!en_scl) begin
            clk_i2c_cntr <= 0;
            clk_i2c <= 1'b1;
        end else begin
            clk_i2c_cntr <= clk_i2c_cntr + 1;
            if (clk_i2c_cntr == DIV_100MHZ - 1) begin
                clk_i2c <= ~clk_i2c;
                clk_i2c_cntr <= 0;
            end
        end
    end
    
    //==========================================================================
    // Main State Machine
    //==========================================================================
    always @(posedge clk or posedge reset_n) begin
        if (reset_n) begin
            // Outputs
            data_out <= 0;
            valid_out <= 0;
            req_data_chunk <= 0;
            busy <= 0;
            nack <= 0;
            
            // Internal state
            addr <= 0;
            rw <= 0;
            sub_addr <= 0;
            sub_len <= 0;
            byte_len <= 0;
            en_scl <= 0;
            byte_sent <= 0;
            num_byte_sent <= 0;
            cntr <= 0;
            byte_sr <= 0;
            read_sub_addr_sent_flag <= 0;
            data_to_write <= 0;
            data_in_sr <= 0;
            ack_nack <= 0;
            ack_in_prog <= 0;
            en_end_indicator <= 0;
            scl_is_high <= 0;
            scl_is_low <= 0;
            grab_next_data <= 0;
            reg_sda_o <= 1'b1;
            reg_sda_oe <= 0;  // Start in high-Z
            state <= IDLE;
            next_state <= IDLE;
        end else begin
            // Default: deassert single-cycle signals
            valid_out <= 0;
            req_data_chunk <= 0;
            
            case (state)
                //==============================================================
                // IDLE - Wait for transaction request
                //==============================================================
                IDLE: begin
                    if (req_trans && !busy) begin
                        busy <= 1;
                        state <= START;
                        next_state <= SLAVE_ADDR;
                        
                        // Latch inputs
                        addr <= i_addr_w_rw;
                        rw <= i_addr_w_rw[0];
                        sub_addr <= i_sub_len ? i_sub_addr : {i_sub_addr[7:0], 8'b0};
                        sub_len <= i_sub_len;
                        data_to_write <= i_data_write;
                        byte_len <= i_byte_len;
                        
                        // Start clock
                        en_scl <= 1;
                        reg_sda_o <= 1;
                        reg_sda_oe <= 1;  // Drive SDA high initially
                        
                        // Reset flags
                        nack <= 0;
                        read_sub_addr_sent_flag <= 0;
                        num_byte_sent <= 0;
                        byte_sent <= 0;
                    end else begin
                        reg_sda_oe <= 0;  // Release SDA when idle
                    end
                end
                
                //==============================================================
                // START - Generate START condition
                //==============================================================
                START: begin
                    if (scl_prev && scl_curr && clk_i2c_cntr == START_IND_SETUP) begin
                        reg_sda_o <= 0;  // Pull SDA low while SCL high
                        reg_sda_oe <= 1;  // Drive SDA
                        byte_sr <= read_sub_addr_sent_flag ? addr : {addr[7:1], 1'b0};
                        state <= SLAVE_ADDR;
                    end
                end
                
                //==============================================================
                // RESTART - Generate repeated START
                //==============================================================
                RESTART: begin
                    if (!scl_curr && scl_prev) begin
                        reg_sda_o <= 1;
                        reg_sda_oe <= 1;
                    end
                    
                    if (!scl_prev && scl_curr) begin
                        scl_is_high <= 1;
                    end
                    
                    if (scl_is_high && clk_i2c_cntr == START_IND_SETUP) begin
                        scl_is_high <= 0;
                        reg_sda_o <= 0;
                        reg_sda_oe <= 1;
                        state <= SLAVE_ADDR;
                        byte_sr <= addr;
                    end
                end
                
                //==============================================================
                // SLAVE_ADDR - Send slave address + R/W bit
                //==============================================================
                SLAVE_ADDR: begin
                    if (byte_sent && cntr[0]) begin
                        byte_sent <= 0;
                        next_state <= read_sub_addr_sent_flag ? READ : SUB_ADDR;
                        byte_sr <= sub_addr[15:8];
                        state <= ACK_NACK_RX;
                        reg_sda_oe <= 0;  // ← CRITICAL! Release SDA for ACK
                        cntr <= 0;
                    end else begin
                        reg_sda_oe <= 1;  // Drive SDA when sending
                        
                        if (!scl_curr && scl_prev) begin
                            scl_is_low <= 1;
                        end
                        
                        if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                            scl_is_low <= 0;
                        end
                    end
                end
                
                //==============================================================
                // SUB_ADDR - Send register address
                //==============================================================
                SUB_ADDR: begin
                    if (byte_sent && cntr[0]) begin
                        if (sub_len) begin
                            state <= ACK_NACK_RX;
                            next_state <= SUB_ADDR;
                            sub_len <= 0;
                            byte_sr <= sub_addr[7:0];
                        end else begin
                            next_state <= rw ? RESTART : WRITE;
                            byte_sr <= rw ? byte_sr : data_to_write;
                            read_sub_addr_sent_flag <= 1;
                        end
                        cntr <= 0;
                        byte_sent <= 0;
                        state <= ACK_NACK_RX;
                        reg_sda_oe <= 0;  // ← Release SDA for ACK
                    end else begin
                        reg_sda_oe <= 1;  // Drive SDA
                        
                        if (!scl_curr && scl_prev) begin
                            scl_is_low <= 1;
                        end
                        
                        if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                            scl_is_low <= 0;
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                        end
                    end
                end
                
                //==============================================================
                // READ - Read data bytes from slave
                //==============================================================
                READ: begin
                    reg_sda_oe <= 0;  // Always release SDA when reading!
                    
                    if (byte_sent) begin
                        byte_sent <= 0;
                        data_out <= data_in_sr;
                        valid_out <= 1;
                        state <= ACK_NACK_TX;
                        next_state <= (num_byte_sent == byte_len - 1) ? STOP : READ;
                        ack_nack <= (num_byte_sent == byte_len - 1);
                        num_byte_sent <= num_byte_sent + 1;
                        ack_in_prog <= 1;
                    end else begin
                        if (!scl_prev && scl_curr) begin
                            scl_is_high <= 1;
                        end
                        
                        if (scl_is_high && clk_i2c_cntr == START_IND_SETUP) begin
                            valid_out <= 0;
                            {byte_sent, cntr} <= cntr + 1;
                            data_in_sr <= {data_in_sr[6:0], sda_prev};
                            scl_is_high <= 0;
                        end
                    end
                end
                
                //==============================================================
                // WRITE - Write data bytes to slave
                //==============================================================
                WRITE: begin
                    reg_sda_oe <= 1;  // Drive SDA when writing
                    
                    if (byte_sent && cntr[0]) begin
                        cntr <= 0;
                        byte_sent <= 0;
                        state <= ACK_NACK_RX;
                        reg_sda_oe <= 0;  // Release for ACK
                        next_state <= (num_byte_sent == byte_len - 1) ? STOP : GRAB_DATA;
                        num_byte_sent <= num_byte_sent + 1;
                        grab_next_data <= 1;
                    end else begin
                        if (!scl_curr && scl_prev) begin
                            scl_is_low <= 1;
                        end
                        
                        if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                            {byte_sent, cntr} <= {byte_sent, cntr} + 1;
                            reg_sda_o <= byte_sr[7];
                            byte_sr <= {byte_sr[6:0], 1'b0};
                            scl_is_low <= 0;
                        end
                    end
                end
                
                //==============================================================
                // GRAB_DATA - Request next byte from controller
                //==============================================================
                GRAB_DATA: begin
                    reg_sda_oe <= 0;  // Don't drive
                    if (grab_next_data) begin
                        req_data_chunk <= 1;
                        grab_next_data <= 0;
                    end else begin
                        state <= WRITE;
                        byte_sr <= i_data_write;
                    end
                end
                
                //==============================================================
                // ACK_NACK_RX - Receive ACK/NACK from slave
                //==============================================================
                ACK_NACK_RX: begin
                    reg_sda_oe <= 0;  // ← MUST release SDA to read ACK!
                    
                    // Sample SDA on SCL rising edge (middle of clock high period)
                    if (!scl_prev && scl_curr) begin
                        // SCL just went high, sample SDA now
                        if (!sda_in) begin
                            // ACK received (SDA LOW)
                            state <= next_state;
                        end else begin
                            // NACK received (SDA HIGH)
                            nack <= 1'b1;
                            busy <= 1'b0;
                            reg_sda_oe <= 0;
                            en_scl <= 1'b0;
                            state <= IDLE;
                        end
                    end
                end
                
                //==============================================================
                // ACK_NACK_TX - Send ACK/NACK to slave
                //==============================================================
                ACK_NACK_TX: begin
                    if (!scl_curr && scl_prev) begin
                        scl_is_low <= 1;
                    end
                    
                    if (scl_is_low && clk_i2c_cntr == DATA_HOLD_TIME) begin
                        if (ack_in_prog) begin
                            reg_sda_o <= ack_nack;
                            reg_sda_oe <= 1;
                            ack_in_prog <= 0;
                        end else begin
                            reg_sda_o <= (next_state == STOP) ? 1'b0 : 1'b1;
                            reg_sda_oe <= (next_state == STOP) ? 1 : 0;
                            en_end_indicator <= (next_state == STOP);
                            state <= next_state;
                        end
                        scl_is_low <= 0;
                    end
                end
                
                //==============================================================
                // STOP - Generate STOP condition
                //==============================================================
                STOP: begin
                    if (!scl_curr && scl_prev && !rw) begin
                        reg_sda_o <= 0;
                        reg_sda_oe <= 1;
                        en_end_indicator <= 1;
                    end
                    
                    if (scl_curr && scl_prev && en_end_indicator) begin
                        scl_is_high <= 1;
                        en_end_indicator <= 0;
                    end
                    
                    if (scl_is_high && clk_i2c_cntr == STOP_IND_SETUP) begin
                        reg_sda_o <= 1;  // Release SDA high
                        reg_sda_oe <= 1;
                        state <= RELEASE_BUS;
                        scl_is_high <= 0;
                    end
                end
                
                //==============================================================
                // RELEASE_BUS - Return to idle
                //==============================================================
                RELEASE_BUS: begin
                    if (clk_i2c_cntr == DIV_100MHZ - 3) begin
                        en_scl <= 0;
                        state <= IDLE;
                        reg_sda_oe <= 0;  // Release SDA
                        busy <= 0;
                    end
                end
                
                default: state <= IDLE;
            endcase
        end
    end
    
    //==========================================================================
    // SDA/SCL Sampling
    //==========================================================================
    always @(negedge clk or posedge reset_n) begin
        if (reset_n) begin
            sda_curr <= 2'b11;
            sda_prev <= 1;
            scl_curr <= 1;
            scl_prev <= 1;
        end else begin
            sda_curr <= {sda_curr[0], sda_in};
            sda_prev <= sda_curr[1];
            scl_curr <= clk_i2c;
            scl_prev <= scl_curr;
        end
    end
    
    //==========================================================================
    // I2C Pin Assignments - FIXED!
    //==========================================================================
    assign sda_out = reg_sda_o;
    assign sda_oe  = reg_sda_oe;  // ← Now uses explicit control!
    
    assign scl_out = clk_i2c;
    assign scl_oe  = en_scl;

endmodule
