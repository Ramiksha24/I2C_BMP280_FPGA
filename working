// I2C Master with ILA Debug Signals
// For Block Diagram: Connect scl/sda to external pins via IOBUF
//                    Connect debug_* signals to ILA for monitoring

module i2c_master_ila (
    input wire clk,              // 100 MHz
    input wire rst_n,            
    
    // Control
    input wire start,            // Pulse to start transaction
    input wire [7:0] slave_addr, // 7-bit address
    input wire [7:0] reg_addr,   // Register to read
    output reg [7:0] data_out,   // Data read
    output reg busy,
    output reg done,
    
    // I2C Physical Pins (connect to IOBUF in block diagram)
    output reg scl,
    inout wire sda,
    
    // Debug signals for ILA monitoring
    output wire debug_sda_out,   // What we're driving on SDA
    output wire debug_sda_in,    // What we're reading from SDA
    output wire debug_sda_en,    // SDA direction (1=output, 0=input)
    output wire [3:0] debug_state,    // Current state
    output wire [3:0] debug_bit_cnt,  // Bit counter
    output wire [7:0] debug_shift_reg // Shift register
);

    // Clock divider for 400kHz: 100MHz / 400kHz = 250
    // We need 4 phases, so divide by 250/4 = 62.5
    // Use 66 to meet tLOW ? 1.3µs requirement (66*4*10ns = 2.64µs period)
    parameter CLKDIV = 66;
    
    reg [7:0] clk_cnt;
    reg [2:0] phase;  // 0,1,2,3 for quarter periods
    reg phase_tick;
    
    // Clock generation
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            clk_cnt <= 0;
            phase <= 0;
            phase_tick <= 0;
        end else if (busy) begin
            if (clk_cnt >= CLKDIV-1) begin
                clk_cnt <= 0;
                phase_tick <= 1;
                if (phase == 3)
                    phase <= 0;
                else
                    phase <= phase + 1;
            end else begin
                clk_cnt <= clk_cnt + 1;
                phase_tick <= 0;
            end
        end else begin
            clk_cnt <= 0;
            phase <= 0;
            phase_tick <= 0;
        end
    end
    
    // State machine
    localparam IDLE = 0, START_BIT = 1, 
               ADDR_W = 2, ACK1 = 3,
               REG_ADDR = 4, ACK2 = 5,
               RESTART = 6, ADDR_R = 7, 
               ACK3 = 8, READ_DATA = 9,
               NACK = 10, STOP_BIT = 11;
    
    reg [3:0] state;
    reg [3:0] bit_cnt;
    reg [7:0] shift_reg;

    
    reg sda_out;
    reg sda_en;  // 0 = master drives, 1 = slave drives

IOBUF IOBUF_sda (
    .IO(sda),        // Physical pin
    .I(sda_out),     // Data master sends
    .O(sda_in),      // Data master reads
    .T(sda_en)       // Direct connection! (not inverted)
);
    
    // Export debug signals for ILA
    assign debug_sda_out = sda_out;
    assign debug_sda_in = sda_in;
    assign debug_sda_en = sda_en;
    assign debug_state = state;
    assign debug_bit_cnt = bit_cnt;
    assign debug_shift_reg = shift_reg;
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            scl <= 1;
            sda_out <= 1;
            sda_en <= 0;
            busy <= 0;
            done <= 0;
            bit_cnt <= 0;
            data_out <= 0;
        end else begin
            done <= 0;
            
            case (state)
                IDLE: begin
                    scl <= 1;
                    sda_out <= 1;
                    sda_en <= 0;
                    busy <= 0;
                    bit_cnt <= 0;
                    if (start) begin
                        busy <= 1;
                        state <= START_BIT;
                    end
                end
                
                START_BIT: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 1;
                                sda_out <= 1;
                                sda_en <= 0;
                            end
                            1: begin
                                // SDA goes LOW while SCL HIGH = START
                                sda_out <= 0;
                            end
                            2: begin
                                // Now SCL goes LOW
                                scl <= 0;
                            end
                            3: begin
                                // Prepare first bit of address
                                shift_reg <= {slave_addr, 1'b0}; // Write bit
                                bit_cnt <= 8;
                                state <= ADDR_W;
                            end
                        endcase
                    end
                end
                
                ADDR_W: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                // SCL LOW - update data
                                scl <= 0;
                                sda_out <= shift_reg[7];
                                sda_en <= 0;
                            end
                            1: begin
                                // SCL rising
                                scl <= 1;
                            end
                            2: begin
                                // SCL HIGH - data stable
                                scl <= 1;
                            end
                            3: begin
                                // SCL falling
                                scl <= 0;
                                shift_reg <= {shift_reg[6:0], 1'b0};
                                bit_cnt <= bit_cnt - 1;
                                if (bit_cnt == 1)
                                    state <= ACK1;
                            end
                        endcase
                    end
                end
                
                ACK1: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_en <= 1; // Release SDA for slave ACK
                            end
                            1: begin
                                scl <= 1;
                            end
                            2: begin
                                scl <= 1;
                                // Sample ACK (should be 0)
                            end
                            3: begin
                                scl <= 0;
                                // Keep sda_oe = 0 for full ACK clock cycle
                                shift_reg <= reg_addr;
                                bit_cnt <= 8;
                                state <= REG_ADDR;
                            end
                        endcase
                    end
                end
                
                REG_ADDR: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_out <= shift_reg[7];
                                sda_en <= 0;
                            end
                            1: begin
                                scl <= 1;
                            end
                            2: begin
                                scl <= 1;
                            end
                            3: begin
                                scl <= 0;
                                shift_reg <= {shift_reg[6:0], 1'b0};
                                bit_cnt <= bit_cnt - 1;
                                if (bit_cnt == 1)
                                    state <= ACK2;
                            end
                        endcase
                    end
                end
                
                ACK2: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_en <= 1;
                            end
                            1: begin
                                scl <= 1;
                            end
                            2: begin
                                scl <= 1;
                            end
                            3: begin
                                scl <= 0;
                                state <= RESTART;
                            end
                        endcase
                    end
                end
                
                RESTART: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_out <= 1;
                                sda_en <= 0;
                            end
                            1: begin
                                // SCL goes HIGH first
                                scl <= 1;
                            end
                            2: begin
                                // Then SDA goes LOW = Repeated START
                                sda_out <= 0;
                            end
                            3: begin
                                scl <= 0;
                                shift_reg <= {slave_addr, 1'b1}; // Read bit
                                bit_cnt <= 8;
                                state <= ADDR_R;
                            end
                        endcase
                    end
                end
                
                ADDR_R: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_out <= shift_reg[7];
                                sda_en <= 0;
                            end
                            1: begin
                                scl <= 1;
                            end
                            2: begin
                                scl <= 1;
                            end
                            3: begin
                                scl <= 0;
                                shift_reg <= {shift_reg[6:0], 1'b0};
                                bit_cnt <= bit_cnt - 1;
                                if (bit_cnt == 1)
                                    state <= ACK3;
                            end
                        endcase
                    end
                end
                
                ACK3: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_en <= 1;
                            end
                            1: begin
                                scl <= 1;
                            end
                            2: begin
                                scl <= 1;
                            end
                            3: begin
                                scl <= 0;
                                bit_cnt <= 8;
                                state <= READ_DATA;
                            end
                        endcase
                    end
                end
                
                READ_DATA: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_en <= 1; // Input mode
                            end
                            1: begin
                                scl <= 1;
                            end
                            2: begin
                                scl <= 1;
                                // Sample data on rising edge
                                shift_reg <= {shift_reg[6:0], sda_in};
                                 if (bit_cnt == 1) begin
                                    data_out <= {shift_reg[6:0], sda_in};
                                end
                            
                            end
                            3: begin
                                scl <= 0;
                                bit_cnt <= bit_cnt - 1;
                                if (bit_cnt == 1) begin
                                    state <= NACK;
                                end
                            end
                        endcase
                    end
                end
                
                NACK: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_out <= 1; // NACK = HIGH
                                sda_en <= 0;
                            end
                            1: begin
                                scl <= 1;
                            end
                            2: begin
                                scl <= 1;
                            end
                            3: begin
                                scl <= 0;
                                state <= STOP_BIT;
                            end
                        endcase
                    end
                end
                
                STOP_BIT: begin
                    if (phase_tick) begin
                        case (phase)
                            0: begin
                                scl <= 0;
                                sda_out <= 0;
                                sda_en <= 0;
                            end
                            1: begin
                                // SCL goes HIGH first
                                scl <= 1;
                            end
                            2: begin
                                // Then SDA goes HIGH = STOP
                                sda_out <= 1;
                            end
                            3: begin
                                done <= 1;
                                busy <= 0;
                                state <= IDLE;
                            end
                        endcase
                    end
                end
                
                default: state <= IDLE;
            endcase
        end
    end

endmodule
